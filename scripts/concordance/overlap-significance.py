import pandas as pd 
import numpy as np
from collections import defaultdict
from matplotlib import pyplot as plt
import seaborn as sns
import argparse
from tqdm import tqdm 

parser = argparse.ArgumentParser(description='Check the significance of overlaped genes')
parser.add_argument('--stat', '-i', type=str, required=True, help='statistics generated by overlapDEtable.py')
parser.add_argument('--label1','-l1',type=str,required=True,help='label of first de table')
parser.add_argument('--label2','-l2',type=str,required=True,help='label of second de table')
parser.add_argument('--iterations','-n',type=int,default=1000,help="number of iterations")
parser.add_argument('--output','-o',type=str,required=True,help='output figure path')
args = parser.parse_args()


def getOverLap(path,label1=args.label1,label2=args.label2,epoches=5):
    overlapDict = defaultdict(list)
    df = pd.read_csv(path,sep="\t",index_col=0)
    common = df.loc[label1+"-null",label2+"-null"]
    nup1 = df.loc[label1+"-up",label2+"-null"]
    ndown1 = df.loc[label1+"-down",label2+"-null"]
    nup2 = df.loc[label1+"-null",label2+"-up"]
    ndown2 = df.loc[label1+"-null",label2+"-down"]
    for epoch in tqdm(range(epoches)):
        numbers = np.arange(common)
        np.random.shuffle(numbers)
        up1 = numbers[:nup1]
        down1 = numbers[nup1:nup1+ndown1]
        numbers = np.arange(common)
        np.random.shuffle(numbers)
        up2 = numbers[:nup2]
        down2 = numbers[nup2:nup2+ndown2]
        overlapDict["{}-up\n{}-up".format(label1,label2)].append(np.intersect1d(up1,up2).shape[0])
        overlapDict["{}-up\n{}-down".format(label1,label2)].append(np.intersect1d(up1,down2).shape[0])
        overlapDict["{}-down\n{}-up".format(label1,label2)].append(np.intersect1d(down1,up2).shape[0])
        overlapDict["{}-down\n{}-down".format(label1,label2)].append(np.intersect1d(down1,down2).shape[0])
    return df,overlapDict

df,overlapDict = getOverLap(args.stat,label1=args.label1,label2=args.label2,epoches=args.iterations)

plotTable = pd.DataFrame(overlapDict)
realizeTable = pd.DataFrame(index=plotTable.columns,columns=["value","std","mean"])
meanValues = plotTable.mean(axis=0)
stdValues = plotTable.std(axis=0)
plotTable = (plotTable-meanValues.values.reshape((1,-1)))/stdValues
plotTable = pd.DataFrame.from_records(plotTable.stack().to_frame().to_records())
del plotTable["level_0"]
realizeTable.loc[meanValues.index,"mean"] = meanValues.values
realizeTable.loc[stdValues.index,"std"] = stdValues.values
realizeTable.loc["{}-up\n{}-up".format(args.label1,args.label2),"value"] = df.loc["{}-up".format(args.label1),"{}-up".format(args.label2)]
realizeTable.loc["{}-up\n{}-down".format(args.label1,args.label2),"value"] = df.loc["{}-up".format(args.label1),"{}-down".format(args.label2)]
realizeTable.loc["{}-down\n{}-up".format(args.label1,args.label2),"value"] = df.loc["{}-down".format(args.label1),"{}-up".format(args.label2)]
realizeTable.loc["{}-down\n{}-down".format(args.label1,args.label2),"value"] = df.loc["{}-down".format(args.label1),"{}-down".format(args.label2)]
realizeTable = (realizeTable["value"]-realizeTable["mean"])/realizeTable["std"]
plotTable.columns = ["concordance","number"]
fig,ax = plt.subplots(figsize=(7,5))
print(realizeTable)
sns.violinplot(data=plotTable,x="concordance",y="number",ax=ax)
ax.scatter(list(realizeTable.index),list(realizeTable.values),s=200,color="black",marker="p")
ax.set_xlim([-0.5,4])
#ax.set_ylim([-50,50])
plt.ylabel("z-score")
plt.savefig(args.output+".pdf",bbox_inches="tight")
